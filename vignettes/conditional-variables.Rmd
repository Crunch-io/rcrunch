<!--
    %\VignetteEngine{knitr::knitr}
    %\VignetteIndexEntry{Datasets: creating, loading, and manipulating}
-->
    
[Previous: exporting data](export.html)
```{r, results='hide', echo=FALSE, message=FALSE}
library(crunch)
load("vignettes.RData")
options(width=120)
```

# Creating variables that depend on other variables

Frequently in data analysis tasks we need to make new variables that are conditional on other variables in our dataset. For example, making variables conditional on others allows us make new categorical variables that are less fine grained than their source variable without combining categories permanently on that variable (say we have a 10-point rating scale, but we also want to make a Net Promoter Score variable that goes from that 10-point scale to a 3 category variable). These types of conditional variables also allow us to combine multiple variables together in interesting ways. Crunch makes this easy and provides a few different ways to accomplish this.

## A few ways, when to use which?

There are two main ways the Crunch package lets us create variables that are conditional on others: there is `makeCaseVariable()`, `interactVariables()`, and `conditionalTransform()`.   
* `makeCaseVariable()` is useful when the new variable is categorical. The main benefits of `makeCaseVariable()` is that all of the computation is done on Crunch's servers, so the operation is much faster than `conditionalTransform()`. Additionally, if the dataset you are using has new data being streamed to it, the variable created with `makeCaseVariable()` will _automatically_ create the new values needed for the new data as it streams in.
* `interactVariables()` is a special case of `makeCaseVariable()`. It takes two or more categorical variables and derives a new variable with the combination of levels from each.
* `conditionalTransform()` is useful when the new variable is not categorical, but rather a different type like numeric or text. The current implementation of `conditionalTransform()` grabs the data needed from the source variable(s) and then creates a new variable in your local R session before returning it to the Crunch servers.

When trying to chose between the two, because of speed and the benefits for streaming data, `makeCaseVariable()` should be used if it is at all possible.

## `makeCaseVariable()`

The `makeCaseVariable()` function derives a variable using values from other
variables. These are evaluated in the order they are supplied either as named expressions or in a list as the `cases` argument (they proceed in an IF, ELSE IF, ELSE IF, ..., ELSE
fashion); the first one that matches selects the name corresponding to that expression.

Let's say we have a survey asking a number of questions about pets owned, opinions about various kinds of pets, as well as opinions about the ACME pet supply company. The variable `ACME_unaided` is a rating from 0--10 of how likely someone is to recommend ACME to a friend when unprompted and `ACME_aided` is a rating from 0--10 of how likely someone is to recommend ACME to a friend when prompted. The large scale is nice for fine-grained distinctions, but what we want here is a three category distinction for use in calculating net promoter score (0 to 6 are detractors, 7 and 8 are neutrals, 9 and 10 are promoters) no matter if it was to the aided or unaided version of the question. With `makeCaseVariable()` this is easy:

```{r, eval=FALSE}
ds_pets$ACME_NPS <- makeCaseVariable(promoter = ACME_unaided >= 9 | ACME_aided >= 9,
                                     neutral = { ACME_unaided >= 7 & ACME_unaided <= 8 } | 
                                         { ACME_aided >= 7 & ACME_aided <= 8 },
                                     detractor = ACME_unaided <= 6 | ACME_aided <= 6,
                                     data = ds_pets,
                                     name = "ACME_NPS")
print(ds_pets$ACME_NPS)
```

```
ACME_NPS (categorical)

          Count
detractor    99
promoter     85
neutral      66
```

This is great for simple conditions, but let's say we actually want to mark the neutrals as missing since we really only care about promoters and detractors. To do this, we can use the `cases` argument instead of listing each case.

```{r, eval=FALSE}
ds_pets$ACME_NPS_no_neutrals <- makeCaseVariable(
    cases = list(list(expression=ACME_unaided >= 9 | ACME_aided >= 9, name="promoter"),
                 list(expression={ ACME_unaided >= 7 & ACME_unaided <= 8 } | 
                                 { ACME_aided >= 7 & ACME_aided <= 8 },
                      name="neutral", missing = TRUE),
                 list(expression=ACME_unaided <= 6 | ACME_aided <= 6, name="detractor")
                 ),
    data = ds_pets,
    name = "ACME_NPS_no_neutrals")

print(ds_pets$ACME_NPS_no_neutrals)
```

```
ACME_NPS_no_neutrals (categorical)

          Count
detractor    99
promoter     85
```

The results are exactly the same (except with the neutrals hidden because we marked them as missing.) We can also set numeric values for each of the cases as well, see the documentation for `makeCaseVariable()` for more details. Additionally this is a fairly simple examples with simple expressions, but `makeCaseVariable()` is powerful and can accept any number of expressions joined together with `&` or `|`. This allows us to use a number of different Crunch variables or local R variables. 

## `interactVariables()`

We have questions about pets as well as where each of those pets spends most of its time. What we want is to make a combined (interacted) variable of `Pet1` (the first pet that the respondent chose) and `Location1` the location where that pet spends most of its time. With `interactVariables()` this is easy. The resulting variable has one category for each of the possible combinations of categories in the two source variables.

```{r, eval=FALSE}
ds_pets$pet1_with_loc <- interactVariables(ds_pets$Pet1, ds_pets$Location1, name = "Pet1 and locations")

print(ds_pets$pet1_with_loc)
```

```
Pet1 and locations (categorical)

                               Count
Cat:Inside                        33
Cat:Outside                       32
Cat:Both inside and outside       26
Bird:Both inside and outside      21
Dog:Outside                       21
Dog:Both inside and outside       17
Bird:Outside                      17
Bird:Inside                       14
Dog:Inside                        14
Lizard:Outside                    12
Lizard:Inside                     11
Lizard:Both inside and outside     8
```

## `conditionalTransform()`

Now imagine that we have two sets of questions, one about what pets one has 
(Pet1, Pet2, Pet3) and then a second that asks about ones opinion of those
 pets that one gave in the Pet* series of questions (Opinion1, Opinion2, 
Opinion3). What we ultimately want is what people's opinion of Cats or 
Dogs is, but because the value of Opinion1, Opinion2, and Opinion3 is 
dependent on the answer to Pet1, Pet2, and Pet3 respectively, we can't 
easily get the overall opinions about Cats. `conditionalTransform()` allows 
you to specify conditions like the following: if variable Pet1 is equal to
'Cat' then use the value from variable Opinion1, if variable Pet2 is 
equal to 'Cat' then use the value from variable Opinion2, etc.
```{r, eval=FALSE}
ds_pets$cat_opinion <- conditionalTransform(
    Pet1 == 'Cat' ~ Opinion1,
    Pet2 == 'Cat' ~ Opinion2,
    Pet3 == 'Cat' ~ Opinion3, 
    data = ds_pets,
    name = "Opinion of Cats")
print(ds_pets$cat_opinion)
```

```
Opinion of Cats (categorical)

                           Count
Strongly Agree                33
Strongly Disagree             28
Disagree                      27
Neither Agree Nor Disagree    26
Agree                         23
```

When returning categories, we can specify what the categories should be 
explicitly with the `categories` argument. This will also order the 
categories in the order that they are given. If no `categories` argument is
given, Crunch will make all of the category labels necesary for the 
resulting variable in the default order (note: this might not include all 
of the categories that are in variables Opinion1, Opinion2, or Opinion3, 
just those levels that are selected by the conditions specified).

```{r, eval=FALSE}
ds_pets$cat_opinion_ordered <- conditionalTransform(
    Pet1 == 'Cat' ~ Opinion1,
    Pet2 == 'Cat' ~ Opinion2,
    Pet3 == 'Cat' ~ Opinion3,
    data = ds_pets, type = "categorical",
    categories = c("Strongly Agree", "Agree", "Neither Agree Nor Disagree",
                   "Disagree", "Strongly Disagree"))

categories(ds_pets$cat_opinion_ordered)
```

```
  id                       name value missing
1  1             Strongly Agree     1   FALSE
2  2                      Agree     2   FALSE
3  3 Neither Agree Nor Disagree     3   FALSE
4  4                   Disagree     4   FALSE
5  5          Strongly Disagree     5   FALSE
6 -1                    No Data    NA    TRUE
```

We can also use `conditionalTransform()` to return a string as well as the
contents of other variables, if for example we want to separate out people
who have only had pets for less than a year, we can specify that as the
first condition (which will be used even if the subsequent conditions are
also true).

```{r, eval=FALSE}
ds_pets$dog_opinion <- conditionalTransform(
    Days_having_Pet1 < 365 ~ "too early to tell",
    Pet1 == 'Dog' ~ Opinion1,
    Days_having_Pet2 < 365 ~ "too early to tell",
    Pet2 == 'Dog' ~ Opinion2,
    Days_having_Pet3 < 365 ~ "too early to tell",
    Pet3 == 'Dog' ~ Opinion3,
    data = ds_pets)
print(ds_pets$dog_opinion)
```

```
dog_opinion (categorical)

                           Count
too early to tell             42
Strongly Agree                25
Agree                         18
Disagree                      18
Strongly Disagree             18
Neither Agree Nor Disagree    16
```
Further, we can also use conditional transform with numeric source variables. This results in a numeric variable as the new variable as well.

```{r, eval=FALSE}
ds_pets$days_with_dog <- conditionalTransform(
    Pet1 == 'Dog' ~ Days_having_Pet1,
    Pet2 == 'Dog' ~ Days_having_Pet2,
    Pet3 == 'Dog' ~ Days_having_Pet3,
    data = ds_pets, type = "numeric")
print(ds_pets$days_with_dog)
```
```
days_with_dog (numeric)

   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
  157.0   519.0   953.0   940.6  1350.0  1726.0     141 
```

`conditionalTransform()` will evaluate `is.na()` or `NA` as conditions or sources 
respectively. In fact, the conditions can be anything returns a `logical`.

```{r, eval=FALSE}
ds_pets$cat_opinion_with_none <- conditionalTransform(
    Pet1 == 'Cat' ~ Opinion1,
    Pet2 == 'Cat' ~ Opinion2,
    Pet3 == 'Cat' ~ Opinion3,
    is.na(Pet1) & is.na(Pet2) & is.na(Pet3) ~ "None",
    data = ds_pets)
print(ds_pets$cat_opinion_with_none)
```

```
cat_opinion_with_none (categorical)

                           Count
Strongly Agree                33
Strongly Disagree             28
Disagree                      27
Neither Agree Nor Disagree    26
Agree                         23
None                          22
```

Finally, when constructing `conditionalTransform()`s, it is frequently helpful 
to automate some parts of the creation; `as.formula()` is helpful here. 
This lets us create a function that we can use to make many conditional 
variables with different questions, responses, and levels that the 
questions take on. 

```{r, eval=FALSE}
opinion_transformation <- function(question_base, response_base, level, dataset) {
    conditionalTransform(
        as.formula(paste0(question_base, "1", " == '", level, "' ~ ", response_base, "1")),
        as.formula(paste0(question_base, "2", " == '", level, "' ~ ", response_base, "2")),
        as.formula(paste0(question_base, "3", " == '", level, "' ~ ", response_base, "3")),
        data = dataset, name = paste(level, response_base)
    )
}

ds_pets$cat_opin <- opinion_transformation(question_base = "Pet",
                                           response_base = "Opinion",
                                           level = "Cat", ds_pets)
ds_pets$dog_opin <- opinion_transformation(question_base = "Pet",
                                           response_base = "Opinion",
                                           level = "Dog", ds_pets)
ds_pets$bird_opin <- opinion_transformation(question_base = "Pet",
                                            response_base = "Opinion",
                                            level = "Bird", ds_pets)
ds_pets$lizard_opin <- opinion_transformation(question_base = "Pet",
                                              response_base = "Opinion",
                                              level = "Lizard", ds_pets)

print(ds_pets[c("cat_opin", "dog_opin", "bird_opin", "lizard_opin")])
```

```
Dataset "Pet Survey"

Contains 250 rows of 4 variables:

$cat_opin: Cat Opinion (categorical)
$dog_opin: Dog Opinion (categorical)
$bird_opin: Bird Opinion (categorical)
$lizard_opin: Lizard Opinion (categorical)
```

```{r, eval=FALSE}
print(ds_pets$lizard_opin)
```
```
Lizard Opinion (categorical)

                           Count
Disagree                      23
Strongly Disagree             18
Agree                         16
Strongly Agree                16
Neither Agree Nor Disagree    11
```