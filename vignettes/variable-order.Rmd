<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Variable Order}
-->

[Previous: array variables](array-variables.html)

```{r, results='hide', echo=FALSE, message=FALSE}
library(crunch)
load("variable-order.RData")
```

# Variable Order and Organization

In the web application, variables in a dataset are displayed vertically on the left side of the screen.

<!-- screenshot -->

Typically, when you import a dataset, the variable list is "flat", which means the variables are not grouped together in any way. But it can be organized into an accordion-like hierarchy similar to how files are show in computers. The variable organizer in the GUI allows you to perform this organization visually (you get there by clicking on the dataset name, then the "Organize" tab assuming you are and editor of that dataset). But you can also manage this metadata from the `crunch` library in R.

## Viewing the order

Picking up with the dataset we used in the [array variables vignette](array-variables.html), we can fetch the `ordering` property of the dataset to view the current organization:

```{r, eval=FALSE}
ordering(ds)
```
```{r, echo=FALSE}
step0
```

It's flat. If you're importing data from a `data.frame` or a file, like an SPSS file, this is where you'll begin.

## Creating groups
Let's say that after some discussion with the client we know how we want the variables organized. We are going place the variables into a small number of groups. There are three steps in this process. 

First, each individual group is generated using the `VariableGroup` function. 
```{r, eval=FALSE}
group1 <- VariableGroup("Demos", ds[c(1:3, 93:118)])
group2 <- VariableGroup("Tracking questions", ds[c(4,5,52:92)])
group3 <- VariableGroup("This week", ds[6:51])
```

After we have created all of the groups, we collect those groups into a container object using the  `VariableOrder` function.

```{r, eval=FALSE}
groups <- VariableOrder(group1, group2, group3)
```

Lastly, we assign this order to the dataset using the `ordering()` function

```{r, eval=FALSE}
ordering(ds) <- groups
```

Now, our variable tree has some structure:

```{r, eval=FALSE}
ordering(ds) # if you look in the GUI you should see all the variables into 3 groups
```
```{r, echo=FALSE}
step1
```

Groups can be created with different kinds of inputs. You can specify a vector or list of variable references (URLs), as returned from the `self` method of variables. That list of references may also contain `VariableGroup` objects as well, which will nest those Groups inside the Group you're creating (see "Nested Groups" below). You can also provide a list of variable entities or, as in this example, a subset of a dataset entity (which can be thought of as a list of variables). 

## Group names
We can use the `names` method to access and modify these group names:

```{r, eval=FALSE}
names(ordering(ds))
```
```{r, echo=FALSE}
names(step1)
```

Let's rename the first group. No need to abbreviate "Demographics".

```{r, eval=FALSE}
names(ordering(ds))[1] <- "Demographics"
names(ordering(ds))
```
```{r, echo=FALSE}
names(step2)
```

## Reordering groups and entities

`VariableOrder` and `VariableGroup` support standard R forms of indexing for extracting and reordering. 

Let's move "Demographics" to the end:

```{r, eval=FALSE}
ordering(ds) <- ordering(ds)[c(2, 3, 1)]
names(ordering(ds))
```
```{r, echo=FALSE}
names(step3)
```

## Nested groups

We can create groups within groups as well. In the "This week" group, we have a set of questions about Edward Snowden: the first four variables in the group. Let's nest them inside their own group called "Snowden" inside the "This week" group:

```{r, eval=FALSE}
ordering(ds)[["This week"]][["Snowden"]] <- ordering(ds)[["This week"]][1:4]
ordering(ds)
```
```{r, echo=FALSE}
step4
```

Note some not obvious things in the code above. First, groups can be extracted by list-like indexing by name. `ordering(ds)[["This week"]]` gives us the `VariableGroup` named "This week". In general, if you want to "grab" a variable group, so that you can see it, edit it, etc... this is a good way to do so.

Second, we can create a new group, nested or otherwise, by assigning in to an Order/Group by a new name. This is similar to extending a named list object by name in base R. In this case, we created a group called "Snowden" inside "This week", and we assigned into it the first four entries of the "This week" group.

Third, the four variable references we put into "Snowden" were also removed from their positions in the "This week" group: they were "moved" rather than copied. This is what we might expect from a files-and-folders form of organization. If you wish to make copies, you can set `duplicates(ordering(ds)) <- TRUE`. If we had done that in this example, we'd have the four Snowden variables appearing both in the "This week" group and in the nested "Snowden" group. (More accurately, and keeping with the file-system metaphor, setting duplicates to `TRUE` lets you create symbolic links rather than actually copying the variables. Only the references are copied; there is only one variable behind them.)

[Next: transforming and deriving](derive.html)