---
title: "Organizing Datasets in Projects"
description: '"Projects" are like folders for your datasets. They allow you to organize datasets into groups and manage access to those bundles of datasets.'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Organizing Datasets in Projects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

> The APIs for projects and organizing datasets within them are currently under development. What is documented here is what currently works, and it will continue to work. There are other methods which work today but that are being deprecated; these methods are not mentioned here. And there may be actions that logically seem like they should work but don't today; they will be supported once the new APIs are completed. Watch this vignette for updates as the APIs evolve.

## Projects

Projects are used to organize datasets into groups and manage access to those bundles of datasets. View your top-level projects with `projects()`:

```r
projects()

##                             name                               id description
## 1                  Daily Surveys 1093171cd5a746b283adf8b7444bebe7            
## 2      Stack Overflow Dev Survey 84f740d53da14a5b8001ac97c8925813            
## 3                 Crunch.io Devs 80c51523fc31446396f6c915a02c77de            
```

To select a project, use standard R list extraction methods.

```r
proj <- projects()[["Crunch.io Devs"]]
```

`newProject()` creates a new top-level project.

```r
proj <- newProject(name="A new start")
projects()


##                             name                               id description
## 1                  Daily Surveys 1093171cd5a746b283adf8b7444bebe7            
## 2      Stack Overflow Dev Survey 84f740d53da14a5b8001ac97c8925813            
## 3                 Crunch.io Devs 80c51523fc31446396f6c915a02c77de   
## 4                    A new start 23deb438a9dde2340091dec23abbbb43
```

Once you have a project in hand, you can put datasets in it and organize them into groups.

## File-system like

Datasets can be organized hierarchically inside of projects. You can think of this like a file system on your computer, with files (datasets) organized into directories (projects, or groups). As such, the main functions you use to manage it are reminiscent of a file system.

* `mkdir()` makes a directory, i.e. creates a group in a project
* `mv()` moves datasets and groups to a different place in the project
* `rmdir()` removes a directory, i.e. deletes a group

Like a file system, you can express the "path" to a folder as a string separated by a "/" delimiter, like this:

```r
mkdir(proj, "Tracking studies/Domestic/Automotive")
```

If your folder names should legitimately have a "/" in them, you can set a different character to be the path separator. See `?mkdir` or any of the other functions' help files for details.

You can also specify paths as a vector of path segments, like

```r
mkdir(proj, c("Tracking studies", "Domestic", "Automotive"))
```

which is equivalent to the previous example. One or the other way may be more convenient, depending on what you're trying to accomplish.

These functions all take a project as the first argument, and they return the same object passed to it. As such, they are designed to work with `magrittr`-style piping (`%>%`) for convenience in chaining together steps, though they don't require that you do.

## Viewing the groups

> During this period of API transition, we'll refer to the organization of datasets into "groups" inside a project as that more accurately reflects the current API and its limited capabilities. In the new API, "projects" will contain other "projects".

To get started, let's look at the contents of our "Crunch.io Devs" project.

```r
proj <- projects()[["Crunch.io Devs"]]
ordering(proj)

# Stack Overflow Developer Survey (2016)
# Stack Overflow Developer Survey (2017)
```

It's flat---there are no groups here, only datasets.

## Creating folders

Let's make some groups and move some datasets into them. To start, we want to setup a folder for the collection of yearly Stack Overflow datasets. We could call `mkdir()` and then `mv()`, but for convenience, `mv()` will create the group specified by your path if it doesn't already exist, so we can use `mv()` alone and get 

```r
ds2016 <- loadDataset("Stack Overflow Developer Survey (2016)", project = proj)
ds2017 <- loadDataset("Stack Overflow Developer Survey (2017)", project = proj)

proj %>%
    mv(ds2016, "Stack Overflow")
proj %>%
    mv(ds2017, "Stack Overflow")
    
ordering(proj)

# [+] Stack Overflow
#     Stack Overflow Developer Survey (2016)
#     Stack Overflow Developer Survey (2017)
```

Now when I print the top-level directory again, I see a "Demos" folder and don't see those demographic variables:

```r
proj

## TODO: print output
```

`mv()` can reference variables or folders within a level in several ways. Numeric indices like we just did probably won't be the most common way you'll do it: names work just as well and are more transparent. Let's move the first variable, `perc_skipped`, into "Demos" as well

```r
ds %>%
    mv("perc_skipped", "Demos") %>%
    cd("Demos") ## To print the folder contents
```

> A side note: although the last step of that chain was `cd()`, we haven't changed state in our R session. There is no "working folder" set globally. `cd()` is a function that returns a folder; if we had assigned the return from the function (pipeline) to some object, we could then pass that in to another function to "start" in that folder.

Another way we can identify variables is by using the `dplyr`-like functions `starts_with`, `ends_with`, `matches`, and `contains`. Let's use `matches` to move all of the questions about Edward Snowden or Bradley (Chelsea) Manning to a folder for the topical questions in this week's survey:

```r
ds %>%
    mkdir("This week") %>%
    mv(matches("manning|snowden", ignore.case = TRUE), "This week")
```

We can also select all variables in a folder using the `variables` function (or all folders within a folder using `folders`). Let's move all remaining variables from the top level folder to a folder called "Tracking questions". To do this, we do need to explicitly change to the top level folder.

```r
ds %>%
    cd("/")
    mkdir("Tracking questions") %>%
    mv(., variables(.), "Tracking questions")
```

> (Curious about the "dot" notation? See the [magrittr docs](http://magrittr.tidyverse.org/articles/magrittr.html).)

The reason we change to the top level folder here is that there is a subtle difference between passing `ds` to `mv()` versus `cd(ds, "/")`. Whatever object, dataset or folder, that is passed into `mv()` determines the scope from which the objects to move are selected. If you pass the dataset in, you can select any variables in the dataset, regardless of what folder they're in. If you pass in a folder, you're selecting just from that folder's contents. It can be convenient to find all variables that match some criteria across the whole dataset to move them, but sometimes we don't want that. In this case, we wanted only the variables sitting in the top level folder, not nested in other folders, so we wanted `variables(cd(ds, "/"))` and not `variables(ds)`.

Now, our variable tree has some structure. Let's use `print(folder, depth = 1)` to see these folders and their contents one level deep:

```r
ds %>%
    cd("/") %>%
    print(depth = 1)
```

## Nested folders

We can create folders within folders as well. In the "This week" folder, we have a set of questions about Edward Snowden. Let's nest them inside their own subfolder inside "This week":

```r
ds %>%
    cd("This week") %>%
    mkdir("Snowden") %>%
    mv(matches("snowden", ignore.case = TRUE), "Snowden") %>%
    cd("..") %>%
    print(depth = 2)
```

Note how we used `".."` to change folders up a level, as you can in a file system . We did that just so we can print the folder structure at the top level (and to illustrate that you can specify relative paths :).

You could also do this using the full path segments. `mkdir` will recursively make all path segments it needs in order to ensure that the target folder exists.

```{r, eval=FALSE}
ds %>%
    mkdir("This week/Snowden") %>%
    mv(matches("snowden", ignore.case = TRUE), "This week/Snowden") %>%
    cd("/") %>%
    print(depth = 2)
```

## Renaming folders and folder contents

Folders themselves have names, which we can set with `setName()`:

```r
ds %>%
    cd("Demos") %>%
    setName("Demographics")
```

We can also set the names of the objects contained in a folder with `setNames()`.

## Ordering within folders

Unlike files in a file system, variables within folders are ordered.

Let's move "Demographics" to the end. One way to do that is with the `setOrder` function. This lets you provide a specific order, but it requires you to specify all of the folder's contents. Let's use that function to put "Tracking questions" first:

```r
ds %>%
    cd("/") %>%
    setOrder(c("Tracking questions", "This week", "Demographics"))
```

<!--
We can do that a couple of ways. One is using `mv()`, giving it the "after" argument

```r
ds %>%
    cd("/") %>%
    mv("Demographics", ".", after="Tracking questions")
```

This uses the `"."` folder "path" to indicate that you're "moving" the object to be in the current folder. Note that `"."` (the current folder) and `.` (the `magrittr` special value) aren't the same thing, though in this particular context, they would have similar implications.

 Note that order of things to mv is preserved, so that does set order

## Finding a variable's folder

folder(ds$var); can also mv to wherever that var is -->

## Deleting folders

The cleanest way to delete a folder is with `rmdir()`:

```r
ds %>%
    rmdir("This week/Snowden")
```

This deletes the folder and all variables contained within it.

[Next: transforming and deriving](derive.html)
