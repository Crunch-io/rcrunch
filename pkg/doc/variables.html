<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Manipulating variables within datasets</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Variables: cleaning and defining metadata}
-->

<p><a href="datasets.html">Previous: create and load datasets</a></p>

<h1>Manipulating variables within datasets</h1>

<p>Once you&#39;ve uploaded data to Crunch, you&#39;ll likely want to spend some time cleaning up the metadata associated with your dataset. Legacy statistical programs offer only limited support for variable metadata, both in type and quality. Because Crunch facilitates data visualization, collaboration, and sharing results with others, making your dataset presentation-quality is worthwhile, and this often requires additional work after uploading a data file. </p>

<p>Most of the operations described below can also be accomplished in the web client. However, users comfortable with scripting may find it faster or easier to automate these actions with <code>crunch</code>. Such edits made within R are carried out on the remote Crunch dataset, thereby keeping data in sync across all client applications.</p>

<h2>A rose by any other moniker: &ldquo;names&rdquo; and &ldquo;aliases&rdquo;</h2>

<p>Crunch takes the principled stand that working with data in the 21st Century should not be constrained by legacies of the punch-card era. Variables should have &ldquo;names&rdquo; that are human-readable and searchable by their meaning&mdash;there is no reason to constrain variable names to be eight characters, all caps, etc. &ldquo;Aided awareness: coffee roasters&rdquo; is much nicer and more presentable than &ldquo;Q2B_V1&rdquo;.</p>

<p>At the same time, shorter, user-defined, unique identifiers for variables do have their uses. For one, it&#39;s what most any legacy statistical software uses for its identifiers, so retaining them on import will help us line up variables when appending a subsequent batch of imported data, for example. For another, when interacting with a dataset from the command line, it can be useful to have shorter, machine-friendlier references. </p>

<p>So, Crunch stores two user-settable identifiers for variables. What you may have thought of as a variable &ldquo;label&rdquo;, Crunch elevates to the status of &ldquo;name&rdquo;. What you may be used to thinking of as a variable &ldquo;name&rdquo;, Crunch calls &ldquo;alias&rdquo;.</p>

<p>Aliases and names have slightly different validation constraints. Aliases must be unique across the entire dataset, including among array <a href="array-variables.html">subvariables</a>. &ldquo;Names&rdquo;, however, only must be unique within <a href="variable-order.html">variable order groups</a>. Any string is valid for either alias or name, though you may want more machine-friendly strings as aliases. In most cases, you probably won&#39;t even set aliases, though: they&#39;ll be set when you import your dataset and will be whatever the names were in your source data.</p>

<p>In sum, name is crunch alias, label is crunch name.</p>

<p>Except in one place in <code>crunch</code>: referencing variables within a dataset.</p>

<h3>Accessing variables within a dataset</h3>

<p>When dealing with variables within a dataset, the alias is used to identify variables. This is because (1) aliases are typically what were used to identify variables in whatever format from which the dataset was imported, and consequently, (2) aliases are typically more machine-friendly as names, less likely to contain characters that are not valid as variable names in R.</p>

<p>Because the <code>names</code> attribute is used for indexing elements in R, if we want to extract variables based on alias, it means that the <code>names</code> attribute of dataset must actually expose aliases. This may be dissonant, but it has some nice properties. For one, comparing our Crunch dataset with the <code>data.frame</code> from which it was created, their <code>names</code> attribute have the same contents:</p>

<pre><code class="r">identical(names(ds), names(df))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>You can reference and extract variables from a dataset as if it were a <code>data.frame</code>, using the <code>$</code>, <code>[</code>, and <code>[[</code> methods. </p>

<pre><code class="r">track.var &lt;- ds$track
</code></pre>

<pre><code class="r">track.var
</code></pre>

<pre><code>## 
##  track (categorical) 
##  
## 
## 
</code></pre>

<pre><code>##                                         Count
## Off on the wrong track                    576
## Generally headed in the right direction   285
## Not sure                                  139
</code></pre>

<p>Like datasets, variables have various attributes like <code>name</code> and <code>description</code> that can be set naturally.</p>

<pre><code class="r">name(track.var) &lt;- &quot;Direction of country&quot;
description(track.var) &lt;- &quot;In your opinon, is the country going in the right direction, or is it on the wrong track?&quot;
</code></pre>

<p>Two caveats. First, because we first extracted the variable from the dataset before making edits, the dataset object has stale metadata for this variable. </p>

<pre><code class="r">name(track.var) == name(ds$track)
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p>If we had instead modified <code>track</code> within <code>ds</code>, like</p>

<pre><code class="r">## Not run
name(ds$track) &lt;- &quot;Direction of country&quot;
</code></pre>

<p><code>ds</code> would be up to date. </p>

<p>This can be remedied one of two ways. We could either assign <code>track.var</code> back to <code>ds</code>, as in</p>

<pre><code class="r">ds$track &lt;- track.var
</code></pre>

<p>or we can just refresh the dataset and fetch data from the server again:</p>

<pre><code class="r">ds &lt;- refresh(ds)
</code></pre>

<p>Now, <code>ds</code> has our edits:</p>

<pre><code class="r">name(track.var) == name(ds$track)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<h3>Addressing the variable catalog</h3>

<p>It is not always convenient that the <code>names</code> attribute of the dataset actually yields <em>aliases</em>. Moreover, if we want to edit the Crunch names of many variables, we need a way of accessing the Crunch metadata more directly. It will be very slow to edit each variable in the dataset individually, referencing them with <code>$</code>, because each edit would send a request to the server. Instead, we&#39;d rather bundle those into a single request. To do this, we can access the <code>variables</code> attribute of the dataset, which is a &ldquo;variable catalog&rdquo;:</p>

<pre><code class="r">class(variables(ds))
</code></pre>

<pre><code>## [1] &quot;VariableCatalog&quot;
## attr(,&quot;package&quot;)
## [1] &quot;crunch&quot;
</code></pre>

<p>In the variable catalog, Crunch names are names, and aliases are aliases. Hence,</p>

<pre><code class="r">identical(names(ds), aliases(variables(ds)))
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>but</p>

<pre><code class="r">identical(names(ds), names(variables(ds)))
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p>because &ldquo;Direction of country&rdquo; is the name for <code>ds$track</code></p>

<pre><code class="r">head(names(variables(ds)), 10)
</code></pre>

<pre><code>##  [1] &quot;starttime&quot;            &quot;endtime&quot;              &quot;perc_skipped&quot;        
##  [4] &quot;newsint2&quot;             &quot;Direction of country&quot; &quot;snowdenfav&quot;          
##  [7] &quot;snowdenleakapp&quot;       &quot;snowdenpros&quot;          &quot;snowdenpenalty&quot;      
## [10] &quot;manningknowledge&quot;
</code></pre>

<p>These attributes all allow assignment with <code>&lt;-</code>. The methods <code>names</code> and <code>aliases</code> yield character vectors, and they take characters in assignment. Hence, you can use any vectorized string manipulation tools available in R, such as regular expressions, to edit variable names efficiently. You can also just supply a replacement vector, like</p>

<pre><code class="r">names(variables(ds))[6:9] &lt;- c(&quot;Favorability of Edward Snowden&quot;, 
                               &quot;Approval of Snowden&#39;s Leak&quot;,
                               &quot;Support for Prosecution of Snowden&quot;,
                               &quot;Penalty for Snowden&quot;)
head(names(variables(ds)), 10)
</code></pre>

<pre><code>##  [1] &quot;starttime&quot;                         
##  [2] &quot;endtime&quot;                           
##  [3] &quot;perc_skipped&quot;                      
##  [4] &quot;newsint2&quot;                          
##  [5] &quot;Direction of country&quot;              
##  [6] &quot;Favorability of Edward Snowden&quot;    
##  [7] &quot;Approval of Snowden&#39;s Leak&quot;        
##  [8] &quot;Support for Prosecution of Snowden&quot;
##  [9] &quot;Penalty for Snowden&quot;               
## [10] &quot;manningknowledge&quot;
</code></pre>

<h2>Categorical variables</h2>

<p>Many variables in survey data are categorial: respondents have a finite set of answers to the survey question, and the answers are first and foremost of a nominal, not quantitative nature. In R, this data type is represented as a <code>factor</code>. The response options, are contained in the factor&#39;s &ldquo;levels&rdquo; as a character vector. Manipulation of these levels is limited and often challenging.</p>

<p>In Crunch, categorical variables&#39; &ldquo;categories&rdquo; are objects with richer metadata. </p>

<pre><code class="r">is.Categorical(track.var)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">categories(track.var)
</code></pre>

<pre><code>## [ 1 ]  Generally headed in the right direction
## [ 2 ]  Off on the wrong track
## [ 3 ]  Not sure
</code></pre>

<h3>Category attributes</h3>

<p>Categories have <code>names</code>, the factor&#39;s levels; numeric <code>values</code> which can be used when interpreting the categorical variable as numeric; and <code>ids</code>, which are analogous to the integer values that underly an R factor. Categories also have their own &ldquo;missing&rdquo; status. Indeed, because Crunch supports more complex missing value support than does R, multiple categories can be marked as missing: there&#39;s not a single &ldquo;NA&rdquo; value.</p>

<pre><code class="r">names(categories(track.var))
</code></pre>

<pre><code>## [1] &quot;Generally headed in the right direction&quot;
## [2] &quot;Off on the wrong track&quot;                 
## [3] &quot;Not sure&quot;
</code></pre>

<pre><code class="r">values(categories(track.var))
</code></pre>

<pre><code>## [1] 1 2 3
</code></pre>

<pre><code class="r">ids(categories(track.var))
</code></pre>

<pre><code>## [1] 1 2 3
</code></pre>

<pre><code class="r">is.na(categories(track.var))
</code></pre>

<pre><code>## Generally headed in the right direction 
##                                   FALSE 
##                  Off on the wrong track 
##                                   FALSE 
##                                Not sure 
##                                   FALSE
</code></pre>

<p>Names and values can be assigned into categories, but ids cannot: they are immutable references to values within the column of data on the server. Missingness can be set with <code>is.na</code>. Character values assigned will mark those categories as missing, leaving other categories unchanged. Logical values assigned will set the missing TRUE/FALSE accordingly.</p>

<pre><code class="r">names(categories(track.var))[1:2] &lt;- c(&quot;Right track&quot;, &quot;Wrong track&quot;)
values(categories(track.var)) &lt;- c(1, -1, 0)
is.na(categories(track.var)) &lt;- &quot;Not sure&quot;
categories(track.var)
</code></pre>

<pre><code>## [ 1 ]  Right track
## [ -1 ]  Wrong track
## [ 0 ]  Not sure
</code></pre>

<!-- MAKE THAT -->

<pre><code class="r">ids(categories(track.var)) &lt;- sample(ids(categories(track.var)), replace=FALSE)
</code></pre>

<pre><code>## Error : Cannot modify category ids
</code></pre>

<h3>Reordering categories</h3>

<p>Categories can also be reordered by index, like any list object</p>

<pre><code class="r">categories(track.var) &lt;- categories(track.var)[c(1,3,2)]
categories(track.var)
</code></pre>

<pre><code>## [ 1 ]  Right track
## [ 0 ]  Not sure
## [ -1 ]  Wrong track
</code></pre>

<p>As with all other metadata edits discussed, updating with these methods automatically sends the changes to the server, so your local edits are reflected in the cloud.</p>

<h2>Hiding variables</h2>

<p>Datasets often contain variables that you may want to use &ndash; perhaps through a derived variable, a transformation, or a recode &ndash; or that may simply not be relevant for the analytic tasks at hand. In short, you want to hide them. They aren&#39;t deleted, so you can restore them if you need them later, but they no longer clutter the dataset &ldquo;workspace&rdquo;.</p>

<p>As when working with a <code>data.frame</code>, you typically assign the return of a dataset-level function back to the variable representing the dataset in your R script or session. </p>

<pre><code class="r">ds &lt;- hideVariables(ds, &quot;comments&quot;)
hiddenVariables(ds)
</code></pre>

<pre><code>## [1] &quot;comments&quot;
</code></pre>

<p>As with the <code>is.na</code> function, you can update a variable by assigning it to the hidden variables list.</p>

<pre><code class="r">hiddenVariables(ds) &lt;- &quot;pid7others&quot;
hiddenVariables(ds)
</code></pre>

<pre><code>## [1] &quot;comments&quot;  &quot;pid7others&quot;
</code></pre>

<p>These variables are now hidden, both locally in your R session and remotely on the server, which you can see in the web application. And, just as you could restore them there, you can also restore them from R:</p>

<pre><code class="r">ds &lt;- unhideVariables(ds, &quot;pid7others&quot;)
hiddenVariables(ds)
</code></pre>

<pre><code>## [1] &quot;comments&quot;
</code></pre>

<p><a href="array-variables.html">Next: create and manipulate array variables</a></p>

</body>

</html>
